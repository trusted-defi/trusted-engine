// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: trusted/v1/service.proto

package trustedv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TrustedServiceClient is the client API for TrustedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TrustedServiceClient interface {
	PoolSetPrice(ctx context.Context, in *SetPriceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PoolGasPrice(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GasPriceResponse, error)
	PendingNonce(ctx context.Context, in *PendingNonceRequest, opts ...grpc.CallOption) (*PendingNonceResponse, error)
	PoolStat(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PoolStatResponse, error)
	PoolContent(ctx context.Context, in *PoolContentRequest, opts ...grpc.CallOption) (*PoolContentResponse, error)
	PoolContentFrom(ctx context.Context, in *PoolContentRequest, opts ...grpc.CallOption) (*PoolContentResponse, error)
	PoolPending(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PoolPendingResponse, error)
	PoolLocals(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PoolLocalsResponse, error)
	AddLocalsTx(ctx context.Context, in *AddTxsRequest, opts ...grpc.CallOption) (*AddTxsResponse, error)
	AddRemoteTx(ctx context.Context, in *AddTxsRequest, opts ...grpc.CallOption) (*AddTxsResponse, error)
	TxStatus(ctx context.Context, in *TxStatusRequest, opts ...grpc.CallOption) (*TxStatusResponse, error)
	TxGet(ctx context.Context, in *TxGetRequest, opts ...grpc.CallOption) (*TxGetResponse, error)
	TxHas(ctx context.Context, in *TxHasRequest, opts ...grpc.CallOption) (*TxHasResponse, error)
	Crypt(ctx context.Context, in *CryptRequest, opts ...grpc.CallOption) (*CryptResponse, error)
	AddLocalTrustedTx(ctx context.Context, in *AddTrustedTxRequest, opts ...grpc.CallOption) (*AddTrustedTxResponse, error)
	AddRemoteTrustedTx(ctx context.Context, in *AddTrustedTxRequest, opts ...grpc.CallOption) (*AddTrustedTxResponse, error)
	FillBlock(ctx context.Context, in *FillBlockRequest, opts ...grpc.CallOption) (*FillBlockResponse, error)
}

type trustedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTrustedServiceClient(cc grpc.ClientConnInterface) TrustedServiceClient {
	return &trustedServiceClient{cc}
}

func (c *trustedServiceClient) PoolSetPrice(ctx context.Context, in *SetPriceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/trusted.v1.TrustedService/PoolSetPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustedServiceClient) PoolGasPrice(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GasPriceResponse, error) {
	out := new(GasPriceResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.TrustedService/PoolGasPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustedServiceClient) PendingNonce(ctx context.Context, in *PendingNonceRequest, opts ...grpc.CallOption) (*PendingNonceResponse, error) {
	out := new(PendingNonceResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.TrustedService/PendingNonce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustedServiceClient) PoolStat(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PoolStatResponse, error) {
	out := new(PoolStatResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.TrustedService/PoolStat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustedServiceClient) PoolContent(ctx context.Context, in *PoolContentRequest, opts ...grpc.CallOption) (*PoolContentResponse, error) {
	out := new(PoolContentResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.TrustedService/PoolContent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustedServiceClient) PoolContentFrom(ctx context.Context, in *PoolContentRequest, opts ...grpc.CallOption) (*PoolContentResponse, error) {
	out := new(PoolContentResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.TrustedService/PoolContentFrom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustedServiceClient) PoolPending(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PoolPendingResponse, error) {
	out := new(PoolPendingResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.TrustedService/PoolPending", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustedServiceClient) PoolLocals(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PoolLocalsResponse, error) {
	out := new(PoolLocalsResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.TrustedService/PoolLocals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustedServiceClient) AddLocalsTx(ctx context.Context, in *AddTxsRequest, opts ...grpc.CallOption) (*AddTxsResponse, error) {
	out := new(AddTxsResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.TrustedService/AddLocalsTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustedServiceClient) AddRemoteTx(ctx context.Context, in *AddTxsRequest, opts ...grpc.CallOption) (*AddTxsResponse, error) {
	out := new(AddTxsResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.TrustedService/AddRemoteTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustedServiceClient) TxStatus(ctx context.Context, in *TxStatusRequest, opts ...grpc.CallOption) (*TxStatusResponse, error) {
	out := new(TxStatusResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.TrustedService/TxStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustedServiceClient) TxGet(ctx context.Context, in *TxGetRequest, opts ...grpc.CallOption) (*TxGetResponse, error) {
	out := new(TxGetResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.TrustedService/TxGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustedServiceClient) TxHas(ctx context.Context, in *TxHasRequest, opts ...grpc.CallOption) (*TxHasResponse, error) {
	out := new(TxHasResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.TrustedService/TxHas", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustedServiceClient) Crypt(ctx context.Context, in *CryptRequest, opts ...grpc.CallOption) (*CryptResponse, error) {
	out := new(CryptResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.TrustedService/Crypt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustedServiceClient) AddLocalTrustedTx(ctx context.Context, in *AddTrustedTxRequest, opts ...grpc.CallOption) (*AddTrustedTxResponse, error) {
	out := new(AddTrustedTxResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.TrustedService/AddLocalTrustedTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustedServiceClient) AddRemoteTrustedTx(ctx context.Context, in *AddTrustedTxRequest, opts ...grpc.CallOption) (*AddTrustedTxResponse, error) {
	out := new(AddTrustedTxResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.TrustedService/AddRemoteTrustedTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trustedServiceClient) FillBlock(ctx context.Context, in *FillBlockRequest, opts ...grpc.CallOption) (*FillBlockResponse, error) {
	out := new(FillBlockResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.TrustedService/FillBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TrustedServiceServer is the server API for TrustedService service.
// All implementations must embed UnimplementedTrustedServiceServer
// for forward compatibility
type TrustedServiceServer interface {
	PoolSetPrice(context.Context, *SetPriceRequest) (*emptypb.Empty, error)
	PoolGasPrice(context.Context, *emptypb.Empty) (*GasPriceResponse, error)
	PendingNonce(context.Context, *PendingNonceRequest) (*PendingNonceResponse, error)
	PoolStat(context.Context, *emptypb.Empty) (*PoolStatResponse, error)
	PoolContent(context.Context, *PoolContentRequest) (*PoolContentResponse, error)
	PoolContentFrom(context.Context, *PoolContentRequest) (*PoolContentResponse, error)
	PoolPending(context.Context, *emptypb.Empty) (*PoolPendingResponse, error)
	PoolLocals(context.Context, *emptypb.Empty) (*PoolLocalsResponse, error)
	AddLocalsTx(context.Context, *AddTxsRequest) (*AddTxsResponse, error)
	AddRemoteTx(context.Context, *AddTxsRequest) (*AddTxsResponse, error)
	TxStatus(context.Context, *TxStatusRequest) (*TxStatusResponse, error)
	TxGet(context.Context, *TxGetRequest) (*TxGetResponse, error)
	TxHas(context.Context, *TxHasRequest) (*TxHasResponse, error)
	Crypt(context.Context, *CryptRequest) (*CryptResponse, error)
	AddLocalTrustedTx(context.Context, *AddTrustedTxRequest) (*AddTrustedTxResponse, error)
	AddRemoteTrustedTx(context.Context, *AddTrustedTxRequest) (*AddTrustedTxResponse, error)
	FillBlock(context.Context, *FillBlockRequest) (*FillBlockResponse, error)
	mustEmbedUnimplementedTrustedServiceServer()
}

// UnimplementedTrustedServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTrustedServiceServer struct {
}

func (UnimplementedTrustedServiceServer) PoolSetPrice(context.Context, *SetPriceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PoolSetPrice not implemented")
}
func (UnimplementedTrustedServiceServer) PoolGasPrice(context.Context, *emptypb.Empty) (*GasPriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PoolGasPrice not implemented")
}
func (UnimplementedTrustedServiceServer) PendingNonce(context.Context, *PendingNonceRequest) (*PendingNonceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PendingNonce not implemented")
}
func (UnimplementedTrustedServiceServer) PoolStat(context.Context, *emptypb.Empty) (*PoolStatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PoolStat not implemented")
}
func (UnimplementedTrustedServiceServer) PoolContent(context.Context, *PoolContentRequest) (*PoolContentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PoolContent not implemented")
}
func (UnimplementedTrustedServiceServer) PoolContentFrom(context.Context, *PoolContentRequest) (*PoolContentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PoolContentFrom not implemented")
}
func (UnimplementedTrustedServiceServer) PoolPending(context.Context, *emptypb.Empty) (*PoolPendingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PoolPending not implemented")
}
func (UnimplementedTrustedServiceServer) PoolLocals(context.Context, *emptypb.Empty) (*PoolLocalsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PoolLocals not implemented")
}
func (UnimplementedTrustedServiceServer) AddLocalsTx(context.Context, *AddTxsRequest) (*AddTxsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLocalsTx not implemented")
}
func (UnimplementedTrustedServiceServer) AddRemoteTx(context.Context, *AddTxsRequest) (*AddTxsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRemoteTx not implemented")
}
func (UnimplementedTrustedServiceServer) TxStatus(context.Context, *TxStatusRequest) (*TxStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TxStatus not implemented")
}
func (UnimplementedTrustedServiceServer) TxGet(context.Context, *TxGetRequest) (*TxGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TxGet not implemented")
}
func (UnimplementedTrustedServiceServer) TxHas(context.Context, *TxHasRequest) (*TxHasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TxHas not implemented")
}
func (UnimplementedTrustedServiceServer) Crypt(context.Context, *CryptRequest) (*CryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Crypt not implemented")
}
func (UnimplementedTrustedServiceServer) AddLocalTrustedTx(context.Context, *AddTrustedTxRequest) (*AddTrustedTxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLocalTrustedTx not implemented")
}
func (UnimplementedTrustedServiceServer) AddRemoteTrustedTx(context.Context, *AddTrustedTxRequest) (*AddTrustedTxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRemoteTrustedTx not implemented")
}
func (UnimplementedTrustedServiceServer) FillBlock(context.Context, *FillBlockRequest) (*FillBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FillBlock not implemented")
}
func (UnimplementedTrustedServiceServer) mustEmbedUnimplementedTrustedServiceServer() {}

// UnsafeTrustedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TrustedServiceServer will
// result in compilation errors.
type UnsafeTrustedServiceServer interface {
	mustEmbedUnimplementedTrustedServiceServer()
}

func RegisterTrustedServiceServer(s grpc.ServiceRegistrar, srv TrustedServiceServer) {
	s.RegisterService(&TrustedService_ServiceDesc, srv)
}

func _TrustedService_PoolSetPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustedServiceServer).PoolSetPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.TrustedService/PoolSetPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustedServiceServer).PoolSetPrice(ctx, req.(*SetPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustedService_PoolGasPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustedServiceServer).PoolGasPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.TrustedService/PoolGasPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustedServiceServer).PoolGasPrice(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustedService_PendingNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PendingNonceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustedServiceServer).PendingNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.TrustedService/PendingNonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustedServiceServer).PendingNonce(ctx, req.(*PendingNonceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustedService_PoolStat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustedServiceServer).PoolStat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.TrustedService/PoolStat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustedServiceServer).PoolStat(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustedService_PoolContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PoolContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustedServiceServer).PoolContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.TrustedService/PoolContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustedServiceServer).PoolContent(ctx, req.(*PoolContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustedService_PoolContentFrom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PoolContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustedServiceServer).PoolContentFrom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.TrustedService/PoolContentFrom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustedServiceServer).PoolContentFrom(ctx, req.(*PoolContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustedService_PoolPending_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustedServiceServer).PoolPending(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.TrustedService/PoolPending",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustedServiceServer).PoolPending(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustedService_PoolLocals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustedServiceServer).PoolLocals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.TrustedService/PoolLocals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustedServiceServer).PoolLocals(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustedService_AddLocalsTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTxsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustedServiceServer).AddLocalsTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.TrustedService/AddLocalsTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustedServiceServer).AddLocalsTx(ctx, req.(*AddTxsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustedService_AddRemoteTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTxsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustedServiceServer).AddRemoteTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.TrustedService/AddRemoteTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustedServiceServer).AddRemoteTx(ctx, req.(*AddTxsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustedService_TxStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustedServiceServer).TxStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.TrustedService/TxStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustedServiceServer).TxStatus(ctx, req.(*TxStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustedService_TxGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustedServiceServer).TxGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.TrustedService/TxGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustedServiceServer).TxGet(ctx, req.(*TxGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustedService_TxHas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxHasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustedServiceServer).TxHas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.TrustedService/TxHas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustedServiceServer).TxHas(ctx, req.(*TxHasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustedService_Crypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustedServiceServer).Crypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.TrustedService/Crypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustedServiceServer).Crypt(ctx, req.(*CryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustedService_AddLocalTrustedTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTrustedTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustedServiceServer).AddLocalTrustedTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.TrustedService/AddLocalTrustedTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustedServiceServer).AddLocalTrustedTx(ctx, req.(*AddTrustedTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustedService_AddRemoteTrustedTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTrustedTxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustedServiceServer).AddRemoteTrustedTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.TrustedService/AddRemoteTrustedTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustedServiceServer).AddRemoteTrustedTx(ctx, req.(*AddTrustedTxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrustedService_FillBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FillBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrustedServiceServer).FillBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.TrustedService/FillBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrustedServiceServer).FillBlock(ctx, req.(*FillBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TrustedService_ServiceDesc is the grpc.ServiceDesc for TrustedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TrustedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "trusted.v1.TrustedService",
	HandlerType: (*TrustedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PoolSetPrice",
			Handler:    _TrustedService_PoolSetPrice_Handler,
		},
		{
			MethodName: "PoolGasPrice",
			Handler:    _TrustedService_PoolGasPrice_Handler,
		},
		{
			MethodName: "PendingNonce",
			Handler:    _TrustedService_PendingNonce_Handler,
		},
		{
			MethodName: "PoolStat",
			Handler:    _TrustedService_PoolStat_Handler,
		},
		{
			MethodName: "PoolContent",
			Handler:    _TrustedService_PoolContent_Handler,
		},
		{
			MethodName: "PoolContentFrom",
			Handler:    _TrustedService_PoolContentFrom_Handler,
		},
		{
			MethodName: "PoolPending",
			Handler:    _TrustedService_PoolPending_Handler,
		},
		{
			MethodName: "PoolLocals",
			Handler:    _TrustedService_PoolLocals_Handler,
		},
		{
			MethodName: "AddLocalsTx",
			Handler:    _TrustedService_AddLocalsTx_Handler,
		},
		{
			MethodName: "AddRemoteTx",
			Handler:    _TrustedService_AddRemoteTx_Handler,
		},
		{
			MethodName: "TxStatus",
			Handler:    _TrustedService_TxStatus_Handler,
		},
		{
			MethodName: "TxGet",
			Handler:    _TrustedService_TxGet_Handler,
		},
		{
			MethodName: "TxHas",
			Handler:    _TrustedService_TxHas_Handler,
		},
		{
			MethodName: "Crypt",
			Handler:    _TrustedService_Crypt_Handler,
		},
		{
			MethodName: "AddLocalTrustedTx",
			Handler:    _TrustedService_AddLocalTrustedTx_Handler,
		},
		{
			MethodName: "AddRemoteTrustedTx",
			Handler:    _TrustedService_AddRemoteTrustedTx_Handler,
		},
		{
			MethodName: "FillBlock",
			Handler:    _TrustedService_FillBlock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "trusted/v1/service.proto",
}

// ChainServiceClient is the client API for ChainService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChainServiceClient interface {
	GetBlock(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockResponse, error)
	GetBalance(ctx context.Context, in *BalanceRequest, opts ...grpc.CallOption) (*BalanceResponse, error)
	GetNonce(ctx context.Context, in *NonceRequest, opts ...grpc.CallOption) (*NonceResponse, error)
	CurrentBlock(ctx context.Context, in *CurrentBlockRequest, opts ...grpc.CallOption) (*CurrentBlockResponse, error)
	LatestHeader(ctx context.Context, in *LatestHeaderRequest, opts ...grpc.CallOption) (*LatestHeaderResponse, error)
	ChainHeadEvent(ctx context.Context, in *ChainHeadEventRequest, opts ...grpc.CallOption) (ChainService_ChainHeadEventClient, error)
}

type chainServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChainServiceClient(cc grpc.ClientConnInterface) ChainServiceClient {
	return &chainServiceClient{cc}
}

func (c *chainServiceClient) GetBlock(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockResponse, error) {
	out := new(BlockResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.ChainService/GetBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainServiceClient) GetBalance(ctx context.Context, in *BalanceRequest, opts ...grpc.CallOption) (*BalanceResponse, error) {
	out := new(BalanceResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.ChainService/GetBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainServiceClient) GetNonce(ctx context.Context, in *NonceRequest, opts ...grpc.CallOption) (*NonceResponse, error) {
	out := new(NonceResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.ChainService/GetNonce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainServiceClient) CurrentBlock(ctx context.Context, in *CurrentBlockRequest, opts ...grpc.CallOption) (*CurrentBlockResponse, error) {
	out := new(CurrentBlockResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.ChainService/CurrentBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainServiceClient) LatestHeader(ctx context.Context, in *LatestHeaderRequest, opts ...grpc.CallOption) (*LatestHeaderResponse, error) {
	out := new(LatestHeaderResponse)
	err := c.cc.Invoke(ctx, "/trusted.v1.ChainService/LatestHeader", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainServiceClient) ChainHeadEvent(ctx context.Context, in *ChainHeadEventRequest, opts ...grpc.CallOption) (ChainService_ChainHeadEventClient, error) {
	stream, err := c.cc.NewStream(ctx, &ChainService_ServiceDesc.Streams[0], "/trusted.v1.ChainService/ChainHeadEvent", opts...)
	if err != nil {
		return nil, err
	}
	x := &chainServiceChainHeadEventClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ChainService_ChainHeadEventClient interface {
	Recv() (*ChainHeadEventResponse, error)
	grpc.ClientStream
}

type chainServiceChainHeadEventClient struct {
	grpc.ClientStream
}

func (x *chainServiceChainHeadEventClient) Recv() (*ChainHeadEventResponse, error) {
	m := new(ChainHeadEventResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ChainServiceServer is the server API for ChainService service.
// All implementations must embed UnimplementedChainServiceServer
// for forward compatibility
type ChainServiceServer interface {
	GetBlock(context.Context, *BlockRequest) (*BlockResponse, error)
	GetBalance(context.Context, *BalanceRequest) (*BalanceResponse, error)
	GetNonce(context.Context, *NonceRequest) (*NonceResponse, error)
	CurrentBlock(context.Context, *CurrentBlockRequest) (*CurrentBlockResponse, error)
	LatestHeader(context.Context, *LatestHeaderRequest) (*LatestHeaderResponse, error)
	ChainHeadEvent(*ChainHeadEventRequest, ChainService_ChainHeadEventServer) error
	mustEmbedUnimplementedChainServiceServer()
}

// UnimplementedChainServiceServer must be embedded to have forward compatible implementations.
type UnimplementedChainServiceServer struct {
}

func (UnimplementedChainServiceServer) GetBlock(context.Context, *BlockRequest) (*BlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlock not implemented")
}
func (UnimplementedChainServiceServer) GetBalance(context.Context, *BalanceRequest) (*BalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBalance not implemented")
}
func (UnimplementedChainServiceServer) GetNonce(context.Context, *NonceRequest) (*NonceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNonce not implemented")
}
func (UnimplementedChainServiceServer) CurrentBlock(context.Context, *CurrentBlockRequest) (*CurrentBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CurrentBlock not implemented")
}
func (UnimplementedChainServiceServer) LatestHeader(context.Context, *LatestHeaderRequest) (*LatestHeaderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LatestHeader not implemented")
}
func (UnimplementedChainServiceServer) ChainHeadEvent(*ChainHeadEventRequest, ChainService_ChainHeadEventServer) error {
	return status.Errorf(codes.Unimplemented, "method ChainHeadEvent not implemented")
}
func (UnimplementedChainServiceServer) mustEmbedUnimplementedChainServiceServer() {}

// UnsafeChainServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChainServiceServer will
// result in compilation errors.
type UnsafeChainServiceServer interface {
	mustEmbedUnimplementedChainServiceServer()
}

func RegisterChainServiceServer(s grpc.ServiceRegistrar, srv ChainServiceServer) {
	s.RegisterService(&ChainService_ServiceDesc, srv)
}

func _ChainService_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainServiceServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.ChainService/GetBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainServiceServer).GetBlock(ctx, req.(*BlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainService_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainServiceServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.ChainService/GetBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainServiceServer).GetBalance(ctx, req.(*BalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainService_GetNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NonceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainServiceServer).GetNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.ChainService/GetNonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainServiceServer).GetNonce(ctx, req.(*NonceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainService_CurrentBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CurrentBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainServiceServer).CurrentBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.ChainService/CurrentBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainServiceServer).CurrentBlock(ctx, req.(*CurrentBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainService_LatestHeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LatestHeaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainServiceServer).LatestHeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/trusted.v1.ChainService/LatestHeader",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainServiceServer).LatestHeader(ctx, req.(*LatestHeaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainService_ChainHeadEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ChainHeadEventRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChainServiceServer).ChainHeadEvent(m, &chainServiceChainHeadEventServer{stream})
}

type ChainService_ChainHeadEventServer interface {
	Send(*ChainHeadEventResponse) error
	grpc.ServerStream
}

type chainServiceChainHeadEventServer struct {
	grpc.ServerStream
}

func (x *chainServiceChainHeadEventServer) Send(m *ChainHeadEventResponse) error {
	return x.ServerStream.SendMsg(m)
}

// ChainService_ServiceDesc is the grpc.ServiceDesc for ChainService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChainService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "trusted.v1.ChainService",
	HandlerType: (*ChainServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBlock",
			Handler:    _ChainService_GetBlock_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _ChainService_GetBalance_Handler,
		},
		{
			MethodName: "GetNonce",
			Handler:    _ChainService_GetNonce_Handler,
		},
		{
			MethodName: "CurrentBlock",
			Handler:    _ChainService_CurrentBlock_Handler,
		},
		{
			MethodName: "LatestHeader",
			Handler:    _ChainService_LatestHeader_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ChainHeadEvent",
			Handler:       _ChainService_ChainHeadEvent_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "trusted/v1/service.proto",
}
